{"pages":[{"title":"","text":"xxx Bridge wa This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.","link":"/album/index.html"},{"title":"","text":"个人简介 -Memento Mori- “毋意、毋必、毋固、毋我“ &thinsp; &thinsp; —《论语·子罕篇》 个人信息： 某校桥梁工学研究室在读博士，主要研究方向：钢桥的高强螺栓连接，铆钉连接以及张拉连接。一般通过实验以及FEM解析进行分析讨论。 喜欢 看动漫（过去式） ，伪军迷（略有所知却一问三不知），喜欢纯音乐，对电子器材略有了解。 大爱Aimer! 爱猫爱狗人士 Skill > 擅长或正在学习 本站推荐索引各种参考 Abaqus Documentation BUNoob.com 时间轴记录","link":"/about/index.html"},{"title":"","text":"来而不往非礼也！","link":"/message/index.html"},{"title":"","text":"欢迎友情链接申请 友情链接申请请点击右侧的Feadback 并发送网站信息。 会在收到消息的第一时间添加。 欢迎各位博客大佬。 本站友链信息如下： 1234图标：https://cdn.jsdelivr.net/gh/ChenYu-K/pic@main/acg/mmexport1600617617091.jpg名称：ChenYu-K地址：https://chenyu-k.github.io/简介：Memento Mori 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"What is progress-bar.dev?https://progress-bar.dev/28/ https://progress-bar.dev/28/?title=progress https://progress-bar.dev/58/ https://progress-bar.dev/58/?title=completed https://progress-bar.dev/91/ https://progress-bar.dev/91/?title=done https://progress-bar.dev/7/?scale=10&amp;title=mark&amp;suffix=X https://progress-bar.dev/420/?scale=500&amp;title=funds&amp;width=120&amp;color=babaca&amp;suffix=$ Heavily inspired by the works of https://github.com/fehmicansaglam/progressed.io","link":"/progress_bar/README.html"},{"title":"","text":"Time machine tips：本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: 'eeccaadc8ba876b69c84', clientSecret: 'ec8fb7eb220a98531e419bf6b9877c5e5292be4a', id: 'self-talking', repo: 'chenyu-k.github.io' owner: 'ChenYu-K', admin: \"ChenYu-K\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"}],"posts":[{"title":"How to select Abaqus Solid Element Type","text":"Abaqus要素タイプの選択 如何选择Abaqus的实体单元类型| | First-order reduced-integration elements|","link":"/2021/08/05/2021-08-05-Abaqus-element-type/"},{"title":"Latex编译下插入png,jpg","text":"\\(\\LaTeX\\)插入png,jpg的设定首先LaTeX本身并不支持插图的功能，插图需要导入graphicx宏包来完成。 在LaTeX用中文或者日语写论文时，编译环境使用Latex较为常见。latex编译模式下如果直接插入png或者jpg的图会告诉你，编译错误没有设置boundbox。 这个时候就需要使用latex+dvipdfmx编译，调用graphicx时需要指定dvipdfmx. \\(\\LaTeX\\)插入图片最好的格式是EPS EPS可以直接插入，而且作为高质量的矢量图片，笔者认为这是论文出图的首选。 设置方法latex直接插入jpg or png，需要设置boundbox，调整bb相当麻烦，两个办法， jpg or png 转换为eps格式（并不推荐） 通过读取dvipdfmx包来自动获取bb信息然后放入文字中。 例如：（笔者喜欢在全局里导入dvipdfmx的条件，当然在调用graphics宏包时导入也可以） 1\\documentclass[a4paper,dvipdfmx]{jsreport} 然后还需要加上bmpsize包来主动获取图片的bb信息，以适配文章格式 1\\usepackage{bmpsize} 注意 color 和 graphics 包同时使用时，必须在documentclass上面添加dvipdfms否则会出现定义不明确的错误，因为color和graphics都是默认div。 对于pdflatex编译模式下pdflatex编译下可以自由导入pdf，jpg，png但是无法导入eps矢量图。这个时候就需要调入epstopdf宏包来支持eps的导入 1\\usepackage{epstopdf} 各种编译方式的图片格式开头也说过，latex本身是不支持导入图片的，导入图片的 格式 矢量图 位图 latex .eps n/a latex + dvipdfmx .eps .pdf .jpg .png .bmp pdflatex .pdf .jpg .png pdflatex 调用epstopdf .eps .pdf .jpg .png xelatex .eps .pdf .jpg .png .bmp 导入图片在调用好宏包之后，就可以正常导入png位图了。在论文中我一般喜欢用以下方式导入 123456\\begin{figure}[htbp] \\centering \\includegraphics[width=\\textwidth]{picture/name.png} \\caption{caption} \\label{label} \\end{figure} Reference dvipdfmx的使用方法 Latex插入多栏图片 Latex_thumbnail来自Jonas Jacek jonas.me，CC BY 4.0，","link":"/2021/08/12/2021-08-12-Latex-pic/"},{"title":"Material_test-data-processing","text":"材料試験自動データ処理 鋼材の材料試験の自動化データ処理スクリプト． 実現できる機能は 降伏点，引張強度の算出．ヤング率，ポアソン比の算出．最後に，自動でグラフを出力，レポートとしてExcelに保存する． Google colab ソースコードsource_code 導入 最初はcsv生データから，必要なデータを読み取り，応力，縦ひずみ平均値と横ひずみ平均値を算出する． ここでは，生データのひずみチャンネル配置によらず，コードで数値の[+，-]を用いて，縦ひずみや横ひずみの判定を行った． 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from glob import globfrom google.colab import driveimport csvimport numpy as npfrom openpyxl import load_workbookimport matplotlib.pyplot as plt ###google driveに接続する．ローカル実行の場合は消してください．drive.mount('/content/drive')%cd '/content/drive/MyDrive/Colab_Notebooks/material_test'###filenames = glob('*.csv')print(filenames) #for filename in filenames:with open('材料試験_H300W_No.1_データリスト.csv',encoding=&quot;utf8&quot;,errors='ignore') as f: f_csv = csv.reader(f) next(f_csv) data = list(f_csv) a = np.array(data) load = a[1:,2] a = a[1:,:] #文字列の次から x = range(np.shape(a)[0]) y = len(data) - 1 #行数を数える case1 = np.empty([y,8],dtype = float) #########################for i in x: case1[i,0] = a[i,2] #load case1[i,1] = a[i,3] #disp if float(a[int(y/2),4]) &gt; 0 : #縦ひずみを判定する case1[i,2] = a[i,4] #縦ひずみ1を定義する if float(a[int(y/2),5]) &gt; 0 : #縦ひずみを判定する case1[i,3] = a[i,5] #縦ひずみ2を定義する case1[i,4] = a[i,6] #横ひずみ1を定義する case1[i,5] = a[i,7] #横ひずみ2を定義する else : case1[i,4] = a[i,5] #横ひずみ1を定義する case1[i,5] = a[i,7] #横ひずみ2を定義する case1[i,3] = a[i,6] #縦ひずみ2を定義する if i == y : break striantate = (case1[:,2]+case1[:,3])/2 #縦ひずみ平均値 strianyoko = (case1[:,4]+case1[:,5])/2 #横ひずみ平均値############################# エクセルシート（テンプレート）を読み込むwb = load_workbook(&quot;template_mt.xlsx&quot;, data_only=True) #エクセルシートを導入するwb1 = wb.active #シートを選択する################# A = wb1['F9'].value #断面積を取得するcase1[:,6] = case1[:,0] *1000/ A #応力の算出 ################# 降伏点の算出方 標準材料試験に対して，ひずみが4000まで，基本降伏点を超えているため，降伏点の算出は： ひずみが4000までの最大応力とする． 引張強度は応力の最大値を取得する． 12345678sigma_y = 0i = 0while striantate[i] &lt; 4000: sigma_y= max(sigma_y,case1[i,6]) i = i+1sigma_u = max(case1[:,6])print('降伏点：',sigma_y)print('引張強度：',sigma_u) 最小二乗法を用いたヤング率の求め 実験の初期ノイズおよび，降伏点付近の塑性化の影響を排除するため，ヤング率の算出範囲は \\(0.2\\sigma_y - 0.7\\sigma_y\\)となった．最小二乗法を用いて，曲線の傾き\\(k_1\\)は以下のように算出された： \\[k_1 =\\frac{n \\sum_{i=1}^{n} x_{i} y_{i}-\\sum_{i=1}^{n} x_{i} \\sum_{i=1}^{n} y_{i}}{n \\sum_{i=1}^{n} x_{i}^{2}-\\left(\\sum_{i=1}^{n} x_{i}\\right)^{2}}\\] コードで見やすいため，以下のように省略で表記する． $$ k_1 = \\frac {na1 - a21\\times a22} {nb1 - a21^2}$$ なお，決定係数\\(R^2\\)については，残差の二乗和を標本値の平均値 \\(\\overline{y}\\)からの偏差の二乗和で割ったものを1から引いた値であり,以下のような式で算出した． $$R^{2} = 1-\\frac{\\sum_{i=1}^{N}\\left(y_{i}-f_{i}\\right)^{2}}{\\sum_{j=1}^{N}\\left(y_{j}-\\bar{y}\\right)^{2}}$$ 123456789101112131415161718192021222324252627i = 0; a1 = 0; a21 = 0; a22 = 0; k1 = 0; b1 = 0; n=0;pc = 0for j in case1[:,6]: if j &gt; 0.2*sigma_y and j &lt; 0.7*sigma_y: a1 += (striantate[i] * case1[i,6]) a21 += striantate[i] a22 += case1[i,6] b1 += striantate[i] ** 2 pc += strianyoko[i]/striantate[i] n += 1 i = i+1k1 = (n*a1 - a21*a22)/(n*b1-a21**2) #yong's modulusb0 = a22/n - k1*a21/n #intercept 切片pc = -pc/n #Poisson coefficient ポアソン比####### R決定係数の求めi = 0; ssr = 0; sst = 0ymean = a22/nfor j in case1[:,6]: if j &gt; 0.2*sigma_y and j &lt; 0.7*sigma_y: ssr += (case1[i,6] - (striantate[i]*k1+b0))**2 sst += (case1[i,6] - ymean)**2 i += 1R2 = 1 - ssr/sst #R2 Coefficient of determination，決定係数######print('ヤング率E = ',k1*10**6)print('ポアソン比 = ',pc)print('決定係数R^2 = ',R2) グラフの出力 matplotlibを用いてグラフの出力 12345678910111213141516171819202122###############グラフを書くplt.plot(striantate,case1[:,6], label=&quot;stress-strain&quot;,color='black',linewidth=0.75)plt.xlabel(&quot;Strain&quot;)plt.ylabel(&quot;Stress [$N/mm^2$]&quot;)plt.ylim(0, 500)plt.xlim(0, 70000)plt.grid(color=&quot;k&quot;, linestyle=&quot;:&quot;) # メッシュ背景を点線に設定するplt.legend(loc=4,numpoints=1) #凡例plt.savefig('stress-strain.svg') #svgとして保存plt.show()################## データを書き込む最後に処理完了したデータを全部Excelテンプレートに書き込む．wb1.cell(6,10,sigma_y)wb1.cell(6,11,sigma_u)wb1.cell(6,12,k1)wb1.cell(6,13,pc)for i in range(3,y) : for j in range(2,8) : wb1.cell(i,j,case1[i-3,j-2]) #シートにi行j列にデータを書き込むwb.save(&quot;111.xlsx&quot;) #保存する Full Code フォルダ内に.csvファイルを探して，名前を取得する． 生データを読み取り，データ処理を行う． 生データから，縦ひずみ，横ひずみ平均値と応力を算出する． 降伏点および引張強度を算出する． 最小二乗法を用いてヤング率およびポアソン比の算出． 応力－ひずみ関係グラフを書く，出力，保存する． 計算結果および生データをテンプレートに保存する． material-test.py >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114from glob import globfrom google.colab import driveimport csvimport numpy as npfrom openpyxl import load_workbookimport matplotlib.pyplot as plt ###drive.mount('/content/drive')%cd '/content/drive/MyDrive/Colab_Notebooks/material_test'filenames = glob('*.csv')###m=1; #生データ書き込むためcellの列数，row1 = 6 #計算結果を書き込むための行数############################# エクセルシート（テンプレート）を読み込むwb = load_workbook(&quot;template_mt.xlsx&quot;, data_only=True) #エクセルシートを導入するwb1 = wb.active #シートを選択する######for filename in filenames: fname = filename.split('_')[-2] with open(filename,encoding=&quot;utf8&quot;,errors='ignore') as f: f_csv = csv.reader(f) next(f_csv) data = list(f_csv) a = np.array(data) load = a[1:,2] a = a[1:,:] #文字列の次から x = range(np.shape(a)[0]) y = len(data) - 1 #行数を数える case1 = np.empty([y,8],dtype = float) ######################### for i in x: case1[i,0] = a[i,2] #load case1[i,1] = a[i,3] #disp if float(a[int(y/2),4]) &gt; 0 : #縦ひずみを判定する case1[i,2] = a[i,4] #縦ひずみ1を定義する if float(a[int(y/2),5]) &gt; 0 : #縦ひずみを判定する case1[i,3] = a[i,5] #縦ひずみ2を定義する case1[i,4] = a[i,6] #横ひずみ1を定義する case1[i,5] = a[i,7] #横ひずみ2を定義する else : case1[i,4] = a[i,5] #横ひずみ1を定義する case1[i,5] = a[i,7] #横ひずみ2を定義する case1[i,3] = a[i,6] #縦ひずみ2を定義する if i == y : break striantate = (case1[:,2]+case1[:,3])/2 #縦ひずみ平均値 strianyoko = (case1[:,4]+case1[:,5])/2 #横ひずみ平均値 ################# A = wb1.cell(row1,6).value #断面積を取得する case1[:,6] = case1[:,0] *1000/ A #応力の算出 #################降伏点および引張強度の算出 sigma_y = 0 i = 0 while striantate[i] &lt; 4000: sigma_y= max(sigma_y,case1[i,6]) i = i+1 sigma_u = max(case1[:,6]) ##############ヤング率の算出 i = 0; a1 = 0; a21 = 0; a22 = 0; k1 = 0; b1 = 0; n=0;pc = 0; for j in case1[:,6]: if j &gt; 0.2*sigma_y and j &lt; 0.7*sigma_y: a1 += (striantate[i] * case1[i,6]) a21 += striantate[i] a22 += case1[i,6] b1 += striantate[i] ** 2 pc += strianyoko[i]/striantate[i] n += 1 i = i+1 k1 = (n*a1 - a21*a22)/(n*b1-a21**2) #yong's modulus b0 = a22/n - k1*a21/n #intercept 切片 pc = -pc/n #Poisson coefficient ポアソン比 ####### R決定係数の求め i = 0; ssr = 0; sst = 0 ymean = a22/n for j in case1[:,6]: if j &gt; 0.2*sigma_y and j &lt; 0.7*sigma_y: ssr += (case1[i,6] - (striantate[i]*k1+b0))**2 sst += (case1[i,6] - ymean)**2 i += 1 R2 = 1 - ssr/sst #R2 Coefficient of determination，決定係数 ##########グラフを書く plt.plot(striantate,case1[:,6], label=&quot;stress-strain&quot;,color='black',linewidth=0.75) plt.xlabel(&quot;Strain&quot;) plt.ylabel(&quot;Stress [$N/mm^2$]&quot;) plt.ylim(0, 500) plt.xlim(0, 70000) plt.grid(color=&quot;k&quot;, linestyle=&quot;:&quot;) # メッシュ背景を点線に設定する plt.legend(loc=4,numpoints=1) #凡例 plt.savefig(fname+'-stress-strain.svg') #svgとして保存 plt.show() ###############データの書き込む wb1.cell(row1,10,sigma_y) wb1.cell(row1,11,sigma_u) wb1.cell(row1,12,k1) wb1.cell(row1,13,pc) for i in range(15,y) : j1 = 0 for j in range(m,m+6) : wb1.cell(i,j,case1[i-15,j1]) #シートにi行j列にデータを書き込む j1 +=1 m += 6 row1 += 1 wb.save(&quot;test.xlsx&quot;) #保存する Matlab ver. Matlabのバージョンも作っています．考え方は基本一緒． material-test.m >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889%%clc %コマンドウインドウをクリアするclear %ワークスペースのクリアfile = dir(fullfile('*.csv')); %csvファイルの情報を全部読み込むfilenames = {file.name}; %csvファイル名を取得[~,n] = size(filenames); %csvファイルの個数を数えるA = readmatrix('template_mt.xlsx','sheet',1,'range','F6:F8'); %断面積を取得する%変数の定義stressmax = 0; avx = 0; avy = 0; avx2 = 0;Sxy = 0; Sx2 = 0; M = 0; Sxy1 = 0; Sxy2 = 0;%%%全てのデータを行列変換%%%%figure figure1 =figure; axes1 = axes('Parent',figure1);hold(axes1,'on');ylabel({'Stress [N/mm^2]'});xlabel({'Strain'});%%%%%%%for i = 1 : n stress_y(i) = 0; k = strcat(filenames(i)); %文字列に変換する data{i,1} = k{1,1}; %名前を付けて data{i,2} = readmatrix(k{1,1}); %データを入れる f = data{i,2}; %data中のi行2列のデータを取り出す f = f(:,3:8); %計測データの3～8列(荷重，変位，ひずみ*4)を取り出す data{i,2} = f; [j,~]=size(data{i,2}); %データ数の列数を数える if data{i,2}(j/2,4)&gt;0 %縦ひずみ2を判定する next; else data{i,2}(:,[4,5]) =data{i,2}(:,[5,4]); %横ひずみと縦ひずみを並び替える end %応力・平均ひずみの出力 for m=1:j stress(m) = data{i,2}(m,1)/A(i)*1000; %`応力の出力 strain(m,1) = 0.5*(data{i,2}(m,3) + data{i,2}(m,4)); strain(m,2) = -0.5*(data{i,2}(m,5) + data{i,2}(m,6)); if strain(m,1) &lt; 4000 stress_y(i)=max(stress(m),stress_y(i)); end end stressmax(i) = max(stress); %応力最大値を取得する %平均値を取得する for m=1:j if (stress(m) &gt; (0.1*stress_y(i))) &amp;&amp; (stress(m) &lt; (0.7*stress_y(i))) avx = avx + strain(m,1); avy = avy + stress(m); avx2 = avx2 + strain(m,2); M = M+1; end end avx = avx/M ; avy = avy/M; avx2 = avx2/M; %最小二乗法 for m=1:j if (stress(m) &gt; (0.1*stress_y(i))) &amp;&amp; (stress(m) &lt; (1.7*stress_y(i))) Sxy = Sxy+(strain(m,1)-avx)*(stress(m)-avy); Sx2 = Sx2+(strain(m,1)-avx)^2; Sxy1 = Sxy1+(strain(m,2)-avx2)*(strain(m,1)-avx); Sxy2 = Sxy2+(strain(m,2)-avx2)^2; end end Yongs(i) = Sxy/Sx2*10^6; b = avy - Yongs * avx; Poissons(i) = Sxy2/Sxy1; plot(strain(:,1),stress); %図の追加endwritematrix(data{1,2},'template_mt.xlsx','sheet',1,'range','A15')writematrix(data{2,2},'template_mt.xlsx','sheet',1,'range','G15')writematrix(data{3,2},'template_mt.xlsx','sheet',1,'range','M15')writematrix(stress_y','template_mt.xlsx','sheet',1,'range','J6')writematrix(stressmax','template_mt.xlsx','sheet',1,'range','K6')writematrix(Yongs','template_mt.xlsx','sheet',1,'range','L6')writematrix(Poissons','template_mt.xlsx','sheet',1,'range','M6')%%%Figurexlim(axes1,[0 70000]);ylim(axes1,[0 500]);box(axes1,'on');hold(axes1,'off');legend1 = legend(axes1,'show');legend('No.1','No.2','No.3','location','southeast');","link":"/2021/08/24/2021-08-24-Material-test/"},{"title":"Preface","text":"Preface zzzzz ummmmmmm","link":"/2021/07/30/Preface/"},{"title":"Abaqus job monitor","text":"运用python对abaqus进行监控 在通过abaqus进行计算时，很多时候通过监视器或者查看.sta文件是太清楚解析算到哪一步的。 运用python对abaqus CAE内置的监视器进行监控管理，特别对于非线性的分析能可以最大限度计算得到自己想要的数据，减少计算成本。 监控原理利用abaqus CAE里的监视器，对模型指定的集合进行监视，分析过程中如果长变量达到某个指定的值就中止分析或者跳过这个分析步之类的指令。这个命令可以用过monitorManager对象中写回调函数（callback function）来完成。 1234567891011def printMessages(jobname,messagetype,data,userdata): print 'job name：%s, messagetype:%s'%(jobname, messagetype) print 'data members:' format = '%-18s %s' print format%('member','value') members = dir(data) for member in members: membervalue = getattr(data,member) print format%(member, membervalue) monitorManager.addMessageCallback(ANY_job,ANY_message_type,printMessages,None) 实例现在我拉伸一块被焊接的钢板，想让他在位移达到1mm的时候停下。 首先对想要监控的区域做一个集合，这里设了点节点52作为监视集合，可以看到.inp文件里会出现如下关键字句。 123***********Nset，nset=monitor, instance=mainplate-1 52,********** *这一句是设置集合的时候自动生成，当然自己添加关键句也是可以的。 其次，在想要监控输出的分析步里，输入参数，这里想要测量的是y方向的位移（U2），关键句如下： 123456789***********Step,name=Step-1, nlgeom, inc=100compress dome*Static, riks0.2, 1., 1e-05,1.0, , monitor, 2, -3.7.....*Monitor, dof=2, node=monitor, frequncy=1 #（这个需要自己添加）*End Step********** 参数：dof=2 指U2位移node=monitor 是指监视名为monitor的集合frequecy=1 监视的频率，可以根据自己的分析步调整，一般为1. python 思路 定义函数 monitorDataValue(), 来输出分析的时间（data.time）和数值（data.value） 12def monitorDataValue(jobName, messageType, data, userData): print &quot;%-8s %s&quot;%(data.time, data.value) 修改函数monitorDataValue()，通过监视集合monitor的U2，使其位移超过1mm的时候就停止计算。 12if data.value &lt; -1 : mdb.jobs[jobName].kill() 调整addMessageCallback()函数中的参数 将参数ANY_job赋值’123‘。（这里job的文件名为123） 将信息类型ANY_Message_type调整为 MONITOR_DATA。 将回调函数名字由printMessages调整为monitorDataValue12monitorManager.addMessageCallback('123', MONITOR_DATA, monitorDataValue, None) 通过CAE或者abaqus command里的’abaqus CAE script = xx.py‘来运行。 完整代码如下 12345678910111213141516# -* - coding:UTF-8 -*-from abaqus import * from abaqusConstants import * import jobfrom jobMessage import *def monitorDataValue(jobName, messageType, data, userData): print &quot;%-8s %s&quot;%(data.time, data.value) if data.value &lt; -1 : mdb.jobs[jobName].kill()monitorManager.addMessageCallback('123', MONITOR_DATA, monitorDataValue, None) job = mdb.JobFromInputFile('123', '123.inp')job.submit() 运行结果 拓展：监视器的功能很强大，可以结合python对很多参数进行监控和控制，比如还可以监控载荷，监控应变，来控制分析步的跳过，中止，以及输出变量之类的。 参考：曹金凤，王旭春，孔亮：Python语言在Abaqus中的应用，机械工业出版社，2011.7","link":"/2021/07/30/abaqusstop/"},{"title":"Hello World","text":"prefaceThis blog will record some of the difficulties and solutions I encountered during my studies, and I will also summarize some basic knowledge related to my profession. AcknowledgementsThe website framework uses Hexo， and the theme is used from Icarus and removeif.","link":"/2021/08/12/hello-world/"},{"title":"How to use right-click to open CMD","text":"右クリックでCMDを素早く起動する方法如何通过右键快速启动CMDMost of time, when we want op the cmd. we should open CMD frst, and then copy the path ,use cd 'path' to start command. Now,you can open CMD from the current path by modifying the registry. Creat a ‘xx.reg’, copy the following code into it,and then run it. 1234567891011121314151617181920212223Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\Directory\\shell\\OpenCmdHere]@=&quot;open cmd&quot;&quot;Icon&quot;=&quot;cmd.exe&quot;[HKEY_CLASSES_ROOT\\Directory\\shell\\OpenCmdHere\\command]@=&quot;cmd.exe /s /k pushd \\&quot;%V\\&quot;&quot;[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCmdHere]@=&quot;open cmd&quot;&quot;Icon&quot;=&quot;cmd.exe&quot;[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCmdHere\\command]@=&quot;cmd.exe /s /k pushd \\&quot;%V\\&quot;&quot;[HKEY_CLASSES_ROOT\\Drive\\shell\\OpenCmdHere]@=&quot;open cmd&quot;&quot;Icon&quot;=&quot;cmd.exe&quot;[HKEY_CLASSES_ROOT\\Drive\\shell\\OpenCmdHere\\command]@=&quot;cmd.exe /s /k pushd \\&quot;%V\\&quot;&quot;[HKEY_CLASSES_ROOT\\LibraryFolder\\background\\shell\\OpenCmdHere]@=&quot;open cmd&quot;&quot;Icon&quot;=&quot;cmd.exe&quot;[HKEY_CLASSES_ROOT\\LibraryFolder\\background\\shell\\OpenCmdHere\\command]@=&quot;cmd.exe /s /k pushd \\&quot;%V\\&quot;&quot;","link":"/2021/08/04/right-click/"}],"tags":[{"name":"Abaqus","slug":"Abaqus","link":"/tags/Abaqus/"},{"name":"Latex","slug":"Latex","link":"/tags/Latex/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Matlab","slug":"Matlab","link":"/tags/Matlab/"},{"name":"Data_processing","slug":"Data-processing","link":"/tags/Data-processing/"},{"name":"Tips","slug":"Tips","link":"/tags/Tips/"}],"categories":[{"name":"Abaqus","slug":"Abaqus","link":"/categories/Abaqus/"},{"name":"Latex","slug":"Latex","link":"/categories/Latex/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Other","slug":"Other","link":"/categories/Other/"},{"name":"computer science","slug":"computer-science","link":"/categories/computer-science/"}]}